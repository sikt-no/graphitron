input EditInputLevel1 @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_RECORD"}) {
  id: ID! @field(name: "someID")
  idWrong: ID
  edit2AWrong: EditInputLevel2A @field(name: "WRONG_JAVA_RECORD")
  edit2BWrong: EditInputLevel2B @field(name: "WRONG_JOOQ_RECORD")
}

input EditInputLevel2A @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_INNER_RECORD"}) {
  i: Int @field(name: "someInt")
}

input EditInputLevel2B @table(name: "CUSTOMER") {
  lastName: String! @field(name: "LAST_NAME")
}

type EditCustomerResponse {
  customer: [Customer] @fetchByID
}

type Mutation {
  editCustomerNested(input: EditInputLevel1!): EditCustomerResponse! @service(service: {name: "TEST_CUSTOMER", method: "editCustomerWithRecordInputsList"})
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @field(name: "FIRST_NAME")
  lastName: String! @field(name: "LAST_NAME")
  email: String
}
