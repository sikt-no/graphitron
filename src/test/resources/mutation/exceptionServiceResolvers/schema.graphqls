input EditInput @table(name : "CUSTOMER") {
  id: ID!
  name: String @field(name: "FIRST_NAME")
  lastName: String @field(name: "LAST_NAME")
  edit2: EditInput2 @field(name : "editDouble")
}

input EditInput2 @table(name : "CUSTOMER") {
  email: String
}

type SomeErrorA implements Error @error(error: {name: "EXCEPTION_TEST"}) {
  path: [String!]!
  message: String!
}

type SomeErrorB implements Error @error(error: {name: "EXCEPTION_TEST_CAUSE", method: "getCauseField"}) {
  path: [String!]!
  message: String!
}

union EditErrorsUnion1 = SomeErrorA
union EditErrorsUnion2 = SomeErrorA | SomeErrorB

type EditCustomerResponse {
  id: ID!
  editCustomerResponse2: EditCustomerResponse2
  editCustomerResponse3: [EditCustomerResponse3!]
  errors: [SomeErrorB!]!
}

type EditCustomerResponseUnion1 {
  id: ID!
  editCustomerResponse2: EditCustomerResponse2
  editCustomerResponse3: [EditCustomerResponse3!]
  errors: [EditErrorsUnion1!]!
}

type EditCustomerResponseUnion2 {
  id: ID!
  editCustomerResponse2: EditCustomerResponse2
  editCustomerResponse3: [EditCustomerResponse3!]
  errors: [EditErrorsUnion2!]!
}

type EditCustomerResponse2 {
  id: ID! @field(name : "id2")
  customer: Customer
}

type EditCustomerResponse3 {
  id: ID! @field(name : "id3")
  customer: Customer @field(name : "customer3")
}

type Mutation {
  editError(input: EditInput!): EditCustomerResponse! @service(service : {name: "TEST_CUSTOMER"})
  editErrorUnion1(name: String! @field(name: "FIRST_NAME")): EditCustomerResponseUnion1! @service(service : {name: "TEST_CUSTOMER"})
  editErrorUnion2(input: EditInput!): EditCustomerResponseUnion2! @service(service : {name: "TEST_CUSTOMER"})
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @field(name: "FIRST_NAME")
  lastName: String! @field(name: "LAST_NAME")
  email: String
}
