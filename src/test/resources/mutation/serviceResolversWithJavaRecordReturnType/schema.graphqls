type EditResponseLevel1 @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_RECORD"}) {
  id: ID! @field(name: "someID")
  idList: [ID]! @field(name: "someListID")
  customer: Customer @field(name: "record")
  customerList: [Customer] @field(name: "recordList")

  edit2A: EditResponseLevel2A
  edit2ADouble: EditResponseLevel2A @field(name: "testCustomerInnerRecord")
  edit2AList: [EditResponseLevel2A] @field(name: "testCustomerInnerRecordList")
  edit2B: EditResponseLevel2B @field(name: "recordList")
  edit2CList: [EditResponseLevel2C] @field(name: "recordList")
}

type EditResponseLevel2A @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_INNER_RECORD"}) {
  hiddenValue: EditResponseLevel3A
  edit3: EditResponseLevel3B! @field(name: "someRecord")
  edit3List: [EditResponseLevel3B!] @field(name: "someRecordList")
}

type EditResponseLevel2B {
  edit3: [EditResponseLevel3B!]
}

type EditResponseLevel2C @record(record: {name: "TEST_CUSTOMER_RECORD"}) {
  edit3: EditResponseLevel3B! @field(name: "record")
}

type EditResponseLevel3A {
  i: Int @field(name: "someInt")
}

type EditResponseLevel3B @table(name: "CUSTOMER") {
  lastName: String! @field(name: "LAST_NAME")
}

type Mutation {
  editCustomer(id: ID!): EditResponseLevel1! @service(service: {name: "TEST_CUSTOMER", method: "editCustomerID"})
}

type Customer implements Node @table {
  id: ID!
  first: String! @field(name: "FIRST_NAME")
  last: String! @field(name: "LAST_NAME")
  email: String
}
