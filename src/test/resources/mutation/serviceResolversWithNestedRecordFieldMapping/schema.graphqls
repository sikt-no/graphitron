input EditInputLevel1 @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_INPUT_RECORD"}) {
  edit2A: EditInputLevel2A
  edit2B: EditInputLevel2B @recordField(name: "recordList")
  edit2C: EditInputLevel2C
  edit2D: [EditInputLevel2D]
  edit2E: [EditInputLevel2E] @recordField(name: "nameList2")
}

input EditInputLevel2A @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_INPUT_INNER_RECORD"}) {
  hiddenValue: EditInputLevel3A
}

input EditInputLevel2B {
  edit3: [EditInputLevel3B!]
}

input EditInputLevel2C {
  lastName: String! @recordField(name: "name")
}

input EditInputLevel2D {
  lastName: String! @field(name: "LAST_NAME") @recordField(name: "nameList1")
}

input EditInputLevel2E {
  lastName: String! @field(name: "LAST_NAME")
}

input EditInputLevel3A {
  i: Int @recordField(name: "someInt")
}

input EditInputLevel3B @table(name: "CUSTOMER") {
  lastName: String! @field(name: "LAST_NAME")
}

type EditCustomerResponse {
  customer: [Customer]
}

type Mutation {
  editCustomerNested(input: EditInputLevel1!): EditCustomerResponse! @service(service: {name: "TEST_CUSTOMER", method: "editCustomerWithRecordInputs"})
}

type Customer implements Node @table {
  id: ID!
}
