input EditInputLevel1 @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_RECORD"}) {
  edit2A: EditInputLevel2A
  edit2ADouble: EditInputLevel2A @field(name: "testCustomerInnerRecord") @field(name: "editDouble") # Field is ignored with java records.
  edit2AList: [EditInputLevel2A] @field(name: "testCustomerInnerRecordList")
  edit2B: EditInputLevel2B @field(name: "recordList")
  edit2CList: [EditInputLevel2C] @field(name: "recordList")
}

input EditInputLevel2A @table(name: "CUSTOMER") @record(record: {name: "TEST_CUSTOMER_INNER_RECORD"}) { # Table is ignored with java records.
  hiddenValue: EditInputLevel3A
  edit3: EditInputLevel3B! @field(name: "someRecord")
  edit3List: [EditInputLevel3B!] @field(name: "someRecordList")
}

input EditInputLevel2B {
  edit3: [EditInputLevel3B!]
}

input EditInputLevel2C @record(record: {name: "TEST_CUSTOMER_RECORD"}) {
  edit3: EditInputLevel3B! @field(name: "record")
}

input EditInputLevel3A {
  i: Int @field(name: "someInt")
}

input EditInputLevel3B @table(name: "CUSTOMER") {
  lastName: String! @field(name: "LAST_NAME")
}

type EditCustomerResponse {
  customer: [Customer]
}

type Mutation {
  editCustomerNested(input: EditInputLevel1!, s: String!): EditCustomerResponse! @service(service: {name: "TEST_CUSTOMER", method: "editCustomerWithRecordInputsList"})
}

type Customer implements Node @table {
  id: ID!
  first: String! @field(name: "FIRST_NAME")
  last: String! @field(name: "LAST_NAME")
  email: String
}
