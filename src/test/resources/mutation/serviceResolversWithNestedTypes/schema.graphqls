input EditInputLevel1 @table(name : "CUSTOMER") {
  id: ID!
  editA1: EditInputLevel2A!
  editA2: EditInputLevel2A @column(name : "editDouble")
  editB: EditInputLevel2B
  editC1: EditInputLevel2C!
  editC2: [EditInputLevel2C!]!
}

input EditInputLevel2A @table(name : "CUSTOMER") {
  firstName: String @column(name : "FIRST_NAME")
}

input EditInputLevel2B @table(name : "CUSTOMER") {
  firstName: String @column(name : "FIRST_NAME")
  edit3: [EditInputLevel3!]
}

input EditInputLevel2C {
  lastName: String! @column(name: "LAST_NAME")
}

input EditInputLevel3 @table(name : "CUSTOMER") {
  email: String
  edit4: [EditInputLevel4!]
}

input EditInputLevel4 @table(name : "CUSTOMER") {
  lastName: String! @column(name: "LAST_NAME")
}

type EditCustomerResponse {
  id: ID!
  EditCustomerResponse2: EditCustomerResponse2
  EditCustomerResponse3: [EditCustomerResponse3!]
}

type EditCustomerResponse2 {
  id: ID! @column(name : "id2")
  customer: Customer
}

type EditCustomerResponse3 {
  id: ID! @column(name : "id3")
  customer: Customer @column(name : "customer3")
  EditCustomerResponse4: [EditCustomerResponse4!] @column(name : "edit4")
}

type EditCustomerResponse4 {
  id: ID! @column(name : "id4")
  payment: Payment @column(name : "payment4")
}

type Mutation {
  editCustomerNested(input: EditInputLevel1!): EditCustomerResponse! @service(name : "TEST_CUSTOMER")
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @column(name: "FIRST_NAME")
  lastName: String! @column(name: "LAST_NAME")
  email: String
  payment: Payment @splitQuery @notGenerated
}

type Payment implements Node @table {
  id: ID!
  amount: Int
  date: DateTime @column(name : "PAYMENT_DATE")
  lastUpdate: DateTime @column(name : "LAST_UPDATE")
}
