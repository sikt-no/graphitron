input EditInputLevel1 @table(name : "CUSTOMER") {
  id: ID!
  editA1: EditInputLevel2A!
  editA2: EditInputLevel2A @field(name : "editDouble")
  editB: EditInputLevel2B
  editC1: EditInputLevel2C!
  editC2: [EditInputLevel2C!]!
}

input EditInputLevel2A @table(name : "CUSTOMER") {
  firstName: String @field(name : "FIRST_NAME")
}

input EditInputLevel2B @table(name : "CUSTOMER") {
  firstName: String @field(name : "FIRST_NAME")
  edit3: [EditInputLevel3!]
}

input EditInputLevel2C {
  lastName: String! @field(name: "LAST_NAME")
}

input EditInputLevel3 @table(name : "CUSTOMER") {
  email: String
  edit4: [EditInputLevel4!]
}

input EditInputLevel4 @table(name : "CUSTOMER") {
  lastName: String! @field(name: "LAST_NAME")
}

type EditCustomerResponse @record(record: {name: "TEST_CUSTOMER_RESPONSE1"}) {
  id: ID!
}


type Mutation {
  editCustomerNested(input: EditInputLevel1!): EditCustomerResponse! @service(service : {name: "TEST_CUSTOMER"})
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @field(name: "FIRST_NAME")
  email: String
}

