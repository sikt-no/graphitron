input EditInput @table(name : "CUSTOMER") {
  id: ID!
  firstName: String @field(name : "FIRST_NAME")
  postalCode: String @field(name : "POSTAL_CODE")
}

type EditResponse @record(record: {name: "TEST_CUSTOMER_RESPONSE1"}) {
  id: ID!
  firstName: String @field(name : "firstName")
  postalCode: String @field(name : "POSTAL_CODE")
}

type EditResponseWithCustomer @record(record: {name: "TEST_CUSTOMER_RESPONSE2"}) {
  id: ID! @field(name: "Id2")
  customerC: Customer @field(name: "customer")
  payment: Payment # Not mapped correctly, won't be included.
}

type Mutation {
  editCustomerSimple(id: ID!): ID! @service(service : {name: "TEST_CUSTOMER", method: "simple"})
  # Note: there are two methods with this name, but it resolves correctly based on number of arguments. Doesn't check the types though.
  editCustomerInput(input: EditInput!): ID! @service(service : {name: "TEST_CUSTOMER"})
  editCustomer2Params(input: EditInput!, lastName: String @field(name: "LAST_NAME")): ID! @service(service : {name: "TEST_CUSTOMER"})
  editCustomerResponse(id: ID!): EditResponse! @service(service : {name: "TEST_CUSTOMER"})
  editCustomerInputAndResponse(input: EditInput!): EditResponse! @service(service : {name: "TEST_CUSTOMER"})
  # Field should not matter. It may change some internal variable names.
  editCustomerWithCustomer(id: ID!): Customer! @field(name : "Terminator") @service(service : {name: "TEST_CUSTOMER"})
  editCustomerWithCustomerResponse(id: ID!): EditResponseWithCustomer! @service(service : {name: "TEST_CUSTOMER"})
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @field(name: "FIRST_NAME")
  lastName: String! @field(name: "LAST_NAME")
  postalCode: String @field(name : "POSTAL_CODE")
  payment: [Payment!]! @splitQuery @notGenerated
  lastUpdate: DateTime @field(name : "LAST_UPDATE")
}

type Payment implements Node @table {
  id: ID!
  amount: Int
  date: DateTime @field(name : "PAYMENT_DATE")
  lastUpdate: DateTime @field(name : "LAST_UPDATE")
}
