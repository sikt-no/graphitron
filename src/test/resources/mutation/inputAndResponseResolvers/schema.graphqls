input EditInput @record(table : "CUSTOMER") {
  id: ID!
  firstName: String @column(name : "FIRST_NAME")
  postalCode: String @column(name : "POSTAL_CODE")
}

type EditResponse {
  id: ID!
  firstName: String @column(name : "FIRST_NAME")
  postalCode: String @column(name : "POSTAL_CODE")
}

type EditResponseWithCustomer {
  id: ID!
  customer: Customer @column(name : "c")
  payment: Payment
}

type Mutation {
  editCustomerSimple(id: ID!): ID! @service(name : "TEST_CUSTOMER")
  " Note: there are two methods with this name, but it resolves correctly based on number of arguments. Doesn't check the types though."
  editCustomerInput(input: EditInput!): ID! @service(name : "TEST_CUSTOMER")
  editCustomer2Params(input: EditInput!, lastName: String @column(name: "LAST_NAME")): ID! @service(name : "TEST_CUSTOMER")
  editCustomerResponse(id: ID!): EditResponse! @service(name : "TEST_CUSTOMER")
  editCustomerInputAndResponse(input: EditInput!): EditResponse! @service(name : "TEST_CUSTOMER")
  " Column should not matter. It may change some internal variable names."
  editCustomerWithCustomer(id: ID!): Customer! @column(name : "Terminator") @service(name : "TEST_CUSTOMER")
  editCustomerWithCustomerResponse(id: ID!): EditResponseWithCustomer! @service(name : "TEST_CUSTOMER")
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @column(name: "FIRST_NAME")
  lastName: String! @column(name: "LAST_NAME")
  postalCode: String @column(name : "POSTAL_CODE")
  payment: [Payment!]! @splitQuery @notGenerated
  lastUpdate: DateTime @column(name : "LAST_UPDATE")
}

type Payment implements Node @table {
  id: ID!
  amount: Int
  date: DateTime @column(name : "PAYMENT_DATE")
  lastUpdate: DateTime @column(name : "LAST_UPDATE")
}
