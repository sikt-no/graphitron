input EditInput @table(name : "CUSTOMER") {
  id: ID!
}

type EditResponse @record(record: {name: "TEST_CUSTOMER_RESPONSE1"}) {
  id: ID!
}

type EditResponseWithCustomer @record(record: {name: "TEST_CUSTOMER_RESPONSE2"}) {
  id: ID! @field(name: "Id2")
}

type Mutation {
  editCustomerSimple(id: ID!): ID! @service(service : {name: "TEST_CUSTOMER", method: "simple"})
  # Note: there are two methods with this name, but it resolves correctly based on number of arguments. Doesn't check the types though.
  editCustomerInput(input: EditInput!): ID! @service(service : {name: "TEST_CUSTOMER"})
  editCustomer2Params(input: EditInput!, lastName: String @field(name: "LAST_NAME")): ID! @service(service : {name: "TEST_CUSTOMER"})
  editCustomerResponse(id: ID!): EditResponse! @service(service : {name: "TEST_CUSTOMER"})
  editCustomerInputAndResponse(input: EditInput!): EditResponse! @service(service : {name: "TEST_CUSTOMER"})
  # Field should not matter. It may change some internal variable names.
  editCustomerWithCustomer(id: ID!): Customer! @field(name : "Terminator") @service(service : {name: "TEST_CUSTOMER"})
  editCustomerWithCustomerResponse(id: ID!): EditResponseWithCustomer! @service(service : {name: "TEST_CUSTOMER"})
}

type Customer implements Node @table {
  id: ID!
}
