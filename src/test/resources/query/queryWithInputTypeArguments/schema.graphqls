type CustomerEmail {
  privateEmail: String @field(name : "EMAIL")
  workEmail: String! @field(name : "EMAIL")
}

type Customer implements Node @table {
  id: ID!
  firstName: String! @field(name: "FIRST_NAME")
  email: CustomerEmail
}

type Query {
  customer: Customer!
  film: Film @notGenerated
}

type FilmCategory implements Node @table(name: "FILM_CATEGORY") {
  id: ID!
  name: String! @field(name: "NAME") @reference(references: [{table: "CATEGORY"}])
}

input OriginalCategoryInput {
  lastUpdated: DateTime! @field(name : "LAST_UPDATED")
  name: Name! @field(name: "NAME") @reference(references: [{table: "CATEGORY"}])
}

input OriginalCategoryInputWithOneField {
  lastUpdated: DateTime! @field(name : "LAST_UPDATED")
}

input OriginalCategoryInputNested {
  originalCategoryField: OriginalCategoryInputWithOneField!
  name: Name! @field(name: "NAME") @reference(references: [{table: "CATEGORY"}])
}

type Film implements Node @table {
  id: ID!
  categories(categoryIn: OriginalCategoryInput!): [FilmCategory!]! @splitQuery
  categoriesForInputList(categoryInList: [OriginalCategoryInput!]): [FilmCategory!]! @splitQuery
  categoriesForMixOfListAndSingleInput(categoryIn: OriginalCategoryInput!, categoryInList: [OriginalCategoryInput!]): [FilmCategory!]! @splitQuery
  categoriesForInputWithOneFieldList(categoryInListOneField: [OriginalCategoryInputWithOneField!]): [FilmCategory!]! @splitQuery
  categoriesForInputWithNestedFieldList(categoryInListNestedField: [OriginalCategoryInputNested!]): [FilmCategory!]! @splitQuery
}

type Name {
  name: String!
}
