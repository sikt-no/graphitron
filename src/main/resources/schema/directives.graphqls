"""Create a new resolver and a separate query for fetching of the annotated field."""
directive @splitQuery on FIELD_DEFINITION

"""
Any field with this directive set is exempt from code generation. This should be used on resolvers that are to be manually implemented.
Can be set on an input field to prevent generation of record mappers.
"""
directive @notGenerated on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

"""Connect this type to a jOOQ table. All the containing fields will by default be assumed to be located there."""
directive @table(name: String) on OBJECT | INPUT_OBJECT

"""
The default assumption for generating fields is that the name of each schema field corresponds exactly to a jOOQ column in the related jOOQ table (set by @table).
This directive overrides the assumption, allowing to correctly map schema field names that diverge from what is available in the table.
"""
directive @field(name: String!) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE

"""Links this schema enum to a Java enum class. Available values are set in the plugin configuration."""
directive @enum(enumReference: ExternalCodeReference!) on ENUM

"""
Use an external service to do the mutation operation.
The signature of the method must match the inputs of the mutation.
Available values are set in the plugin configuration.
"""
directive @service(service: ExternalCodeReference!) on FIELD_DEFINITION

"""
Map this type to a Java exception class.
Only applicable on types that implement the Error interface.
Available values are set in the plugin configuration.
"""
directive @error(error: ExternalCodeReference!) on OBJECT

"""
Helps create connections between tables where a simple implicit join would be insufficient.
In addition, this directive permits fields to be mapped to different tables than their surrounding object.
If neither table or key are provided and none can be automatically inferred, the condition is assumed to be sufficient to complete the join.
"""
directive @reference(
  """The jOOQ table to connect to."""
  table: String

  """The key to use to create this reference."""
  key: String,

  """Extra condition for this reference. Available values are set in the plugin configuration."""
  condition: ExternalCodeReference,

  """Extra reference steps that must be taken to complete the mapping."""
  via: [ReferenceElement!]
) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

"""Adjust constraints for this field, argument or input field."""
directive @condition(
  """Condition to be used. Available values are set in the plugin configuration."""
  condition: ExternalCodeReference,
  """If true, this condition should be used instead of the usual checks that are generated."""
  override: Boolean = false
) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @lookupKey on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION
directive @mutation(typeName: MutationType!) on FIELD_DEFINITION

"""Handle this input argument as orderBy functionality"""
directive @orderBy on ARGUMENT_DEFINITION

"""Connect this enum value to an index with the given name"""
directive @index(name: String) on ENUM_VALUE

"""Wrap input in given record."""
directive @record(record: ExternalCodeReference) on INPUT_OBJECT

"""Map input to a record field."""
directive @recordField(name: String) on INPUT_FIELD_DEFINITION

enum MutationType { UPDATE, DELETE, INSERT, UPSERT }

input ExternalCodeReference { name: String!, method: String }

input ReferenceElement { table: String, key: String, condition: ExternalCodeReference }

