# Graphitron Mental Model

This document describes the conceptual foundation for Graphitron's architecture.

---

## What Graphitron Does

Graphitron generates GraphQL DataFetchers from jOOQ-mapped types. You define a GraphQL schema with `@table` directives pointing to your jOOQ tables, and Graphitron generates complete, working DataFetchers with:

- Selection-set-driven column selection (no over-fetching)
- Nested queries using jOOQ's `row()` and `multiset()`
- N+1 prevention built in
- Type-safe, compile-time validated

**This is the core value proposition.** If you just want GraphQL over service methods, you're probably better off with a different framework. Graphitron's power is in generating jOOQ query code.

---

## Security Model

Graphitron is designed to be used with row-level security (RLS) in the database. The generated code executes queries directly against your tablesâ€”it does not add authorization logic at the application layer.

If you're using RLS, the database enforces access control regardless of which fields are queried or how queries are nested. This is the intended architecture.

If you're not using RLS, your mileage may vary and your data may not be secure.

---

## Staying in jOOQ-Land

The goal is to stay in jOOQ-land as much as possible. From a schema like this:

```graphql
type Query {
  users: [User!]!
  user(id: ID! @lookupKey): User
}

type User @table(name: "USERS") {
  id: ID!
  name: String!
  email: String! @field(name: "EMAIL_ADDRESS")
  orders: [Order!]! @reference(path: [{ table: "ORDERS", key: "FK_ORDERS_USER" }])
}

type Order @table(name: "ORDERS") {
  id: ID!
  status: String!
  total: Float!
}
```

Graphitron generates DataFetchers that build jOOQ queries from selection sets, with nested fetching and column selection handled automatically.

---

## Adding Custom Logic

When you need logic beyond simple column mapping, Graphitron provides two mechanisms that keep you in jOOQ-land:

### Conditions

Filter results by pointing to a method that returns a jOOQ `Condition`. The method receives the jOOQ table as its first argument:

```graphql
type User @table(name: "USERS") {
  activePosts: [Post!]!
    @reference(path: [{
      table: "POSTS",
      key: "FK_POSTS_USER",
      condition: { className: "com.example.Conditions", method: "isActive" }
    }])
}
```

```java
public class Conditions {
    public static Condition isActive(Posts post) {
        return post.STATUS.eq("ACTIVE");
    }
}
```

This is the preferred way to add filtering logic.

### Calculated Fields (@externalField)

Derive values by pointing to a method that returns a jOOQ `Field<T>`. The method receives the jOOQ table as its first argument:

```graphql
type User @table(name: "USERS") {
  fullName: String! @externalField
}
```

```java
public static Field<String> fullName(Users users) {
    return DSL.concat(users.FIRST_NAME, DSL.val(" "), users.LAST_NAME);
}
```

The return type is validated against the GraphQL field type at build time.

### Arguments

Both conditions and calculated fields can receive additional arguments mapped from the GraphQL schema:

```graphql
type User @table(name: "USERS") {
  posts(status: PostStatus): [Post!]!
    @reference(path: [{
      table: "POSTS",
      key: "FK_POSTS_USER",
      condition: { className: "com.example.Conditions", method: "byStatus" }
    }])
}
```

```java
public static Condition byStatus(Posts post, PostStatus status) {
    return status != null 
        ? post.STATUS.eq(status.name()) 
        : DSL.trueCondition();
}
```

Non-scalar arguments must be mapped to a corresponding type in the service layer: use `@table` if mapping to a jOOQ TableRecord, or `@record` if mapping to a Java record.

---

## The N+1 Rule

| Field position | Times called | Implication |
|----------------|--------------|-------------|
| Root (Query/Mutation) | Once | Can do any work |
| Non-root | N times (per parent) | Must be trivial or DataLoader-backed |

This eliminates N+1 by design.

---

## @service: The Escape Hatch

When you need data from outside jOOQ:

```graphql
type Recommendation @service(service: { className: "com.example.RecommendationService", method: "getForUser" }) {
  productId: ID!
  product: Product!  # Re-entry to jOOQ-land
}
```

**Minimize @service usage.** Get back to jOOQ-land as quickly as possible via re-entry fields.

---

## Build-Time Guarantees

Graphitron validates at build time:
- Tables and columns exist in jOOQ catalog
- Condition methods exist and return `Condition`
- Calculated field methods exist and return compatible `Field<T>`
- Service methods exist with correct signatures
- Re-entry paths are valid

---

## Summary

| Concept | Key Point |
|---------|-----------|
| Core Value | Generate jOOQ queries from GraphQL selection sets |
| Security | Designed for row-level security in the database |
| Goal | Stay in jOOQ-land; minimize @service usage |
| Custom Logic | Conditions for filtering, @externalField for derived values |
| Arguments | Methods receive table + GraphQL arguments; non-scalars need @table or @record |
| N+1 Rule | Non-root fields must be trivial or DataLoader-backed |
| Build-time | Validate everything; fail fast with good errors |

---

**See also:**
- GEP-002: Parse-and-Validate Architecture
- GEP-003: Selection-Set-Driven Query Generation
