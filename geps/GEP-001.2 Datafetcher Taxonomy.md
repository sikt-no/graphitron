# Graphitron DataFetcher Taxonomy

> **⚠️ DEPRECATED:** This document is being superseded by [Code Generation Patterns](../docs/CODE-GENERATION-PATTERNS.md).
>
> **Why:** DataFetcher is just GraphQL-Java wiring. What matters is what Graphitron generates: **Queries and QueryParts**. The new document organizes around:
> - **`<Type>Queries` classes** - One per GraphQL type
> - **Query execution methods** - Root fields execute complete SQL
> - **Loader methods** - `@splitQuery` fields execute batched SQL
> - **QueryPart helpers** - Inline fields generate `multiset()`/`row()` fragments
> - **QueryPart extensions** - `@condition`/`@externalField` return jOOQ QueryParts
> - **Service escape** - `@service` leaves QueryPart generation
>
> This reflects what Graphitron actually does: generates jOOQ query code (Queries) and SQL fragments (QueryParts), not DataFetcher types.
>
> This document remains for historical reference but should not be used as the primary guide.

---

## Original Content (Historical Reference)

This document categorizes the DataFetcher patterns that Graphitron generates and the conditions that trigger each one.

-----

## Foundational Concepts

### The N+1 Rule

| Position | Times Called | Constraint |
|----------|--------------|------------|
| Root (Query/Mutation) | Once | Can do any work |
| Non-root | N times | Must be trivial or DataLoader-backed |

### Source Modes

| Source Mode | What `env.getSource()` returns | Origin |
|-------------|-------------------------------|--------|
| jOOQ Record | `Record` or `Result` | `@table`-backed query |
| Java Record | POJO / Java Record | `@service` method return |

### TrivialDataFetcher

GraphQL-Java's marker interface for DataFetchers that only extract/map data. Safe to call N times.

### Key Terminology

- **jOOQ-land**: Code path where source is a jOOQ Record, queries built with jOOQ DSL
- **Re-entry**: Transitioning from Java Record source (after `@service`) back to jOOQ-land
- **SplitQuery**: Optimization within jOOQ-land—use DataLoader batching instead of inline multiset

-----

## Category 1: Root Query DataFetchers

Entry points on the Query type. Called once per request.

### LookupDataFetcher

**Trigger conditions:**
- Field is on `Query` type
- Has argument(s) with `@lookupKey` directive
- Return type has `@table` directive

```graphql
type Query {
  users(ids: [ID!]! @lookupKey): [User]!
  user(key: UserKey! @lookupKey): User
}

input UserKey {
  tenantId: ID!
  odataId: ID!
}
```

**Behavior:** Fetches by unique key(s). Returns ordered list matching input (1:1 correspondence).

---

### NodeDataFetcher

**Trigger conditions:**
- Field is on `Query` type
- Field name is `node`
- Return type is `Node` interface
- Argument is `id: ID!`

```graphql
type Query {
  node(id: ID!): Node
}

interface Node {
  id: ID!
}

type User @table(name: "USERS") @node(typeId: "User") implements Node {
  id: ID!
}
```

**Behavior:** Decodes Relay global ID → type + PK. Delegates to type-specific DataLoader.

---

### FilterDataFetcher

**Trigger conditions:**
- Field is on `Query` type
- Return type is a `*Connection` type
- No required search/query argument

```graphql
type Query {
  users(filter: UserFilter, first: Int, after: String): UserConnection!
}
```

**Behavior:** Start with all records, narrow down via structured filter. Always paginated.

---

### SearchDataFetcher

**Trigger conditions:**
- Field is on `Query` type
- Return type is a `*Connection` type
- Has argument marked with `@search` directive, OR
- Has required argument named `query` or `search` of type `String!`

```graphql
type Query {
  # Explicit @search directive
  searchUsers(q: String! @search, filter: UserFilter, first: Int): UserConnection!
  
  # Implicit by naming convention
  searchProducts(query: String!, filter: ProductFilter, first: Int): ProductConnection!
}
```

**Behavior:** Full-text or relevance search. Start with nothing, find matches. Can combine with filter. Always paginated.

---

### ListDataFetcher

**Trigger conditions:**
- Field is on `Query` type
- Return type is list of `@table` type (not Connection)
- No pagination arguments
- Typically for small, bounded, slowly-changing data

```graphql
type Query {
  countries: [Country!]!
  orderStatuses: [OrderStatus!]!
}
```

**Behavior:** Simple list fetch. Use sparingly—prefer FilterDataFetcher for most cases.

---

### EntityDataFetcher

**Trigger conditions:**
- Apollo Federation schema detected
- Field name is `_entities` on `Query` type

```graphql
# Generated by Federation - not in your schema
type Query {
  _entities(representations: [_Any!]!): [_Entity]!
}
```

**Behavior:** Resolves entity representations from supergraph router. Infrastructure only—not user-facing.

-----

## Category 2: Connection Field DataFetchers

Generated for specific fields on `*Connection` types.

### TotalCountDataFetcher

**Trigger conditions:**
- Parent type name ends with `Connection`
- Field name is `totalCount`
- Field type is `Int!` or `Int`

```graphql
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!  # ← Triggers TotalCountDataFetcher
}
```

**Behavior:** Executes separate `SELECT COUNT(*)` query against same table/conditions. Only executed if field is requested in selection set.

---

**Note:** `edges`, `pageInfo`, and `nodes` fields on Connection types use trivial extraction from the paginated query results—not separate DataFetchers.

-----

## Category 3: Mutation DataFetchers

Entry points on the Mutation type.

**Detection:** Graphitron uses explicit `@mutation` directive OR infers from naming conventions. The directive takes precedence and is recommended for clarity.

### InsertDataFetcher

**Trigger conditions:**
- Field is on `Mutation` type
- Has `@mutation(type: INSERT)` directive, OR
- Field name matches pattern: `create*`, `insert*`, `add*`

```graphql
type Mutation {
  # Inferred from naming
  createUser(input: CreateUserInput!): User!
  
  # Explicit directive (recommended)
  addProduct(input: ProductInput!): Product! @mutation(type: INSERT)
}
```

---

### UpdateDataFetcher

**Trigger conditions:**
- Field is on `Mutation` type
- Has `@mutation(type: UPDATE)` directive, OR
- Field name matches pattern: `update*`, `modify*`, `edit*`

```graphql
type Mutation {
  updateUser(id: ID!, input: UpdateUserInput!): User!
}
```

---

### DeleteDataFetcher

**Trigger conditions:**
- Field is on `Mutation` type
- Has `@mutation(type: DELETE)` directive, OR
- Field name matches pattern: `delete*`, `remove*`

```graphql
type Mutation {
  deleteUser(id: ID!): Boolean!
}
```

---

### UpsertDataFetcher

**Trigger conditions:**
- Field is on `Mutation` type
- Has `@mutation(type: UPSERT)` directive, OR
- Field name matches pattern: `upsert*`, `save*`

```graphql
type Mutation {
  upsertUser(input: UpsertUserInput!): User!
}
```

-----

## Category 4: Subtype DataFetchers

For polymorphic types (unions and interfaces) where concrete type must be determined at runtime. These generate both DataFetchers (for efficient querying) and TypeResolvers (for GraphQL type determination).

### SingleTableSubtypeDataFetcher

**Trigger conditions:**
- Type is `interface` or `union`
- Has `@discriminate(on: "COLUMN_NAME")` directive
- All implementing/member types share the same `@table`

```graphql
interface Content @discriminate(on: "CONTENT_TYPE") {
  id: ID!
  createdAt: DateTime!
}

type Post @table(name: "CONTENT") @discriminator(value: "POST") implements Content {
  id: ID!
  createdAt: DateTime!
  title: String!
}

type Comment @table(name: "CONTENT") @discriminator(value: "COMMENT") implements Content {
  id: ID!
  createdAt: DateTime!
  body: String!
}
```

**Behavior:** 
- Single query against shared table
- Discriminator column included in SELECT
- TypeResolver reads discriminator to determine GraphQL type
- Field resolution based on concrete type

---

### MultitableSubtypeDataFetcher

**Trigger conditions:**
- Type is `interface` or `union`
- Member types have different `@table` directives
- No shared discriminator column

```graphql
union SearchResult = User | Product | Order

type User @table(name: "USERS") { ... }
type Product @table(name: "PRODUCTS") { ... }
type Order @table(name: "ORDERS") { ... }
```

**Behavior:**
- Fan-out queries to multiple tables
- Merge and possibly sort results
- TypeResolver determines type from which table the record came from
- More complex and expensive than single-table

-----

## Category 5: Service DataFetcher

Escape hatch from jOOQ-land to call custom Java code.

### ServiceDataFetcher

**Trigger conditions:**
- Field has `@service` directive

```graphql
type User @table(name: "USERS") {
  recommendations: [Recommendation!]! 
    @service(class: "com.example.RecService", method: "forUser")
}

type Recommendation {  # No @table - this is a Java Record
  score: Float!
  reason: String!
  product: Product!  # May need re-entry to get back to jOOQ-land
}
```

**Behavior:** 
- Calls developer-provided Java method
- Method receives parent record and any field arguments
- Returns Java Record(s) or POJO(s)
- Child fields enter Java Record source mode
- May need re-entry DataFetchers to get back to jOOQ-land

-----

## Category 6: SplitQuery DataFetcher

Optimization within jOOQ-land. Uses DataLoader batching instead of inline multiset/row.

### SplitQueryDataFetcher

**Trigger conditions:**
- Field has `@splitQuery` directive
- Parent type has `@table` (already in jOOQ-land)
- Typically combined with `@reference` to specify FK

```graphql
type User @table(name: "USERS") {
  # Without @splitQuery: inline multiset in parent query
  # With @splitQuery: separate batched query via DataLoader
  orders: [Order!]! @reference(fk: "USER_ID") @splitQuery
}

type Order @table(name: "ORDERS") {
  # Many-to-one also supported
  user: User! @reference(fk: "USER_ID") @splitQuery
}
```

**How relationship direction is determined:**

The `@reference` directive provides FK information. Graphitron infers direction from cardinality and FK location:

| GraphQL Field | FK Location | Direction | Inference |
|---------------|-------------|-----------|-----------|
| `User.orders: [Order!]!` | On Order table (ORDERS.USER_ID) | One-to-many | List return type, FK points to parent |
| `Order.user: User!` | On Order table (ORDERS.USER_ID) | Many-to-one | Singular return type, FK on parent |

**Behavior depends on relationship direction:**

| Relationship | Extract from Parent | Query | Result Mapping |
|--------------|---------------------|-------|----------------|
| One-to-many (User→Orders) | Parent PK (USERS.ID) | `WHERE ORDERS.USER_ID IN (?)` | Group by FK |
| Many-to-one (Order→User) | FK value (ORDERS.USER_ID) | `WHERE USERS.ID IN (?)` | Direct by PK |

**When to use @splitQuery:**
- Large nested collections that would bloat parent query
- Conditional fetching where nested data is often not requested
- Breaking up overly complex queries

**Default behavior (without @splitQuery):** Nested relationships are built inline using multiset (one-to-many) or row (many-to-one/one-to-one) in the parent DataFetcher's query. Child fields use JooqRecordDataFetcher for trivial extraction.

-----

## Category 7: Re-entry DataFetchers

Transition from Java Record source (after `@service`) back to jOOQ-land. Always DataLoader-backed.

**How Graphitron detects re-entry type:**

At code generation time, Graphitron inspects the Java Record class returned by the `@service` method. For each GraphQL field on the service result type:

1. Find the corresponding Java Record component (by field name or `@field` mapping)
2. Check the component's Java type:
   - `extends TableRecord<?>` → TableRecordReentryDataFetcher
   - `String` + field returns `Node` type → NodeIdReentryDataFetcher  
   - Otherwise → PropertyDataFetcher

### TableRecordReentryDataFetcher

**Trigger conditions:**
- Parent type does NOT have `@table` (source is Java Record)
- Field's return type has `@table`
- Java Record component is a jOOQ TableRecord with PK populated

```graphql
type Recommendation {  # Java Record from @service
  score: Float!
  product: Product! @field(name: "productRecord")
}

type Product @table(name: "PRODUCTS") {
  id: ID!
  name: String!
  price: Float!
}
```

```java
// Service method returns this
public record RecommendationResult(
    float score,
    String reason,
    ProductsRecord productRecord  // jOOQ TableRecord - only PK populated
) {}
```

**Behavior:**
1. Extract PK from TableRecord component: `source.productRecord().getId()`
2. DataLoader batches all PKs across the request
3. Single query: `SELECT * FROM PRODUCTS WHERE ID IN (?pks)`
4. Return full jOOQ Record for each PK
5. Child fields now in jOOQ-land again

---

### NodeIdReentryDataFetcher

**Trigger conditions:**
- Parent type does NOT have `@table` (source is Java Record)
- Field returns `Node` interface or type with `@node` directive
- Java Record component is a String containing Relay global ID

```graphql
type Recommendation {  # Java Record from @service
  score: Float!
  relatedItem: Node! @field(name: "relatedItemId")
}
```

```java
public record RecommendationResult(
    float score,
    String relatedItemId  // Relay global ID: "Product:123"
) {}
```

**Behavior:**
1. Extract global ID string: `source.relatedItemId()`
2. Decode: "Product:123" → type="Product", pk=123
3. DataLoader groups by type, batches PKs within each type
4. Query each type's table: `SELECT * FROM PRODUCTS WHERE ID IN (?)`
5. Return appropriate jOOQ Record for each global ID
6. Child fields now in jOOQ-land again

-----

## Category 8: Trivial DataFetchers

Extraction only. Implements `TrivialDataFetcher`. No I/O. Safe to call N times.

### JooqRecordDataFetcher

**Trigger conditions:**
- Parent type has `@table` (source is jOOQ Record)
- No `@splitQuery` or `@service` directive
- Field is one of:
  - Direct column mapping
  - Table method returning `Field<T>`
  - External virtual field returning `Field<T>`
  - Relationship field with `@reference` (no `@splitQuery`) — extracts nested Result/Record

```graphql
type User @table(name: "USERS") {
  # Direct column
  id: ID!
  
  # Column with explicit mapping  
  email: String! @field(name: "EMAIL_ADDR")
  
  # Table method → adds Field<T> to SELECT
  fullName: String! @field(name: "getFullName")
  
  # Relationship without @splitQuery → nested multiset, trivial extraction
  orders: [Order!]! @reference(fk: "USER_ID")
  
  # Relationship without @splitQuery → nested row, trivial extraction
  address: Address @reference(fk: "ADDRESS_ID")
}
```

**Behavior:** 
- For columns/methods: Extracts value from jOOQ Record by column name or alias
- For nested relationships: Extracts `Result<?>` (multiset) or `Record` (row) that was built inline in parent query

---

### PropertyDataFetcher

**Trigger conditions:**
- Parent type does NOT have `@table` (source is Java Record from `@service`)
- Field maps to simple property (not TableRecord, not Node ID)

```graphql
type Recommendation {  # Java Record from @service
  score: Float!
  reason: String! @field(name: "explanation")  # Maps to different property name
}
```

**Behavior:** GraphQL-Java built-in PropertyDataFetcher. Extracts property from Java object by name.

-----

## Summary: Generation Trigger Matrix

| DataFetcher | Location | Key Trigger |
|-------------|----------|-------------|
| **Root Query** | | |
| LookupDataFetcher | Query field | `@lookupKey` on argument |
| NodeDataFetcher | Query.node | Returns `Node` interface |
| FilterDataFetcher | Query field | Returns `*Connection`, no search arg |
| SearchDataFetcher | Query field | Returns `*Connection`, has search arg |
| ListDataFetcher | Query field | Returns list, no pagination |
| EntityDataFetcher | Query._entities | Federation schema |
| **Connection Field** | | |
| TotalCountDataFetcher | *Connection.totalCount | `totalCount` field on Connection |
| **Mutation** | | |
| InsertDataFetcher | Mutation field | `@mutation(type: INSERT)` or `create*` |
| UpdateDataFetcher | Mutation field | `@mutation(type: UPDATE)` or `update*` |
| DeleteDataFetcher | Mutation field | `@mutation(type: DELETE)` or `delete*` |
| UpsertDataFetcher | Mutation field | `@mutation(type: UPSERT)` or `upsert*` |
| **Subtype** | | |
| SingleTableSubtypeDataFetcher | Interface/Union | `@discriminate` + shared `@table` |
| MultitableSubtypeDataFetcher | Interface/Union | Different `@table` per member |
| **Service** | | |
| ServiceDataFetcher | Any field | `@service` directive |
| **SplitQuery** | | |
| SplitQueryDataFetcher | @table type field | `@splitQuery` directive |
| **Re-entry** | | |
| TableRecordReentryDataFetcher | Java Record field | Component is TableRecord |
| NodeIdReentryDataFetcher | Java Record field | Component is String, returns Node |
| **Trivial** | | |
| JooqRecordDataFetcher | @table type field | Column/nested extraction |
| PropertyDataFetcher | Java Record field | Simple property extraction |

-----

## Decision Tree

```
Field Definition
│
├─ On Query type?
│  ├─ Has @lookupKey argument? ─────────────────► LookupDataFetcher
│  ├─ Named "node", returns Node? ──────────────► NodeDataFetcher
│  ├─ Named "_entities"? ───────────────────────► EntityDataFetcher
│  ├─ Returns *Connection?
│  │  ├─ Has search/query argument? ────────────► SearchDataFetcher
│  │  └─ No search argument? ───────────────────► FilterDataFetcher
│  └─ Returns simple list? ─────────────────────► ListDataFetcher
│
├─ On Mutation type?
│  ├─ @mutation(type: INSERT) or create/insert/add* ─► InsertDataFetcher
│  ├─ @mutation(type: UPDATE) or update/modify/edit* ► UpdateDataFetcher
│  ├─ @mutation(type: DELETE) or delete/remove* ─────► DeleteDataFetcher
│  └─ @mutation(type: UPSERT) or upsert/save* ───────► UpsertDataFetcher
│
├─ On *Connection type?
│  └─ Named "totalCount"? ──────────────────────► TotalCountDataFetcher
│
├─ Interface or Union?
│  ├─ @discriminate + shared @table? ───────────► SingleTableSubtypeDataFetcher
│  └─ Different @table per member? ─────────────► MultitableSubtypeDataFetcher
│
├─ Has @service directive? ─────────────────────► ServiceDataFetcher
│
├─ Has @splitQuery directive? ──────────────────► SplitQueryDataFetcher
│
├─ Parent has @table? (jOOQ Record source)
│  └─ Column or nested result? ─────────────────► JooqRecordDataFetcher
│
└─ Parent is Java Record? (@service result)
   ├─ Component is TableRecord? ────────────────► TableRecordReentryDataFetcher
   ├─ Component is String, returns Node? ───────► NodeIdReentryDataFetcher
   └─ Simple property? ─────────────────────────► PropertyDataFetcher
```

-----

## What Modifies DataFetchers (Not Separate Types)

### @reference Directive

Declares a relationship between types and specifies the FK used to join them. Required for relationship fields.

```graphql
type User @table(name: "USERS") {
  # One-to-many: FK is on the target table
  orders: [Order!]! @reference(fk: "USER_ID")
  
  # Many-to-one: FK is on this table
  department: Department! @reference(fk: "DEPARTMENT_ID")
}
```

**Effect on query generation:**
- Without `@splitQuery`: Builds inline multiset (one-to-many) or row (many-to-one) in parent query
- With `@splitQuery`: Uses FK for DataLoader batching

### @condition Directive

Adds WHERE clauses to jOOQ queries. Can be applied to any jOOQ-backed DataFetcher.

```graphql
type User @table(name: "USERS") {
  activePosts: [Post!]! 
    @condition(name: "com.example.PostConditions.isActive")
}
```

```java
public class PostConditions {
    public static Condition isActive() {
        return POST.STATUS.eq("ACTIVE")
            .and(POST.DELETED_AT.isNull());
    }
}
```

**Applies to:** FilterDataFetcher, SearchDataFetcher, LookupDataFetcher, SplitQueryDataFetcher, inline multiset/row queries in parent DataFetchers

### @field Directive

Maps GraphQL field to jOOQ column, table method, or Java Record component. Affects extraction and query building, not DataFetcher type.

```graphql
type User @table(name: "USERS") {
  # Column mapping (simple name → column)
  email: String! @field(name: "EMAIL_ADDRESS")
  
  # Table method (simple name → method on jOOQ Table class returning Field<T>)
  fullName: String! @field(name: "getFullName")
  
  # External virtual field (fully qualified → static method returning Field<T>)
  avatar: String! @field(name: "com.example.AvatarService.getAvatarUrl")
}
```

Table methods and external virtual fields return `Field<T>` or `SelectField<T>` which gets included in the SQL query. They stay in jOOQ-land—the method builds a query part, not fetches data separately.

-----

## Open Questions / Future Work

1. **Facets on SearchDataFetcher** — Additional aggregation field on Connection for search faceting (not yet implemented)

2. **Subscription type** — Not supported. Graphitron focuses on Query and Mutation.

3. **Batch mutations** — Pattern for bulk insert/update/delete operations

-----

**See also:**
- GEP-001: Parse-and-Validate Architecture
- GEP-002: Selection-Set-Driven Query Generation
- Graphitron Mental Model
