extend type Query {
    helloWorldAgain(name: String!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    helloWorldAgainWithJooqRecordInput(input: CustomerInput!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    helloWorldAgainWithJavaRecordInput(input: HelloWorldInputObject!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    """Query to test @nodeId transformation to jOOQ record in @record input"""
    helloWorldWithNodeIdToJooqRecord(input: NodeIdToJooqInputObject!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    """Query to test merging of two @nodeId fields into one jOOQ record"""
    helloWorldWithNodeIdMerging(input: NodeIdMergingInputObject!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    """Query to test conflict detection when overlapping @nodeId fields have different values"""
    helloWorldWithNodeIdConflict(input: NodeIdConflictInputObject!): HelloWorldObject @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    helloWorldWithSplitQueryField(addressIds: [String]!): [HelloWorldObject] @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    helloWorldWithSplitQueryListField: [HelloWorldObject] @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})
    helloWorldWithNullResolverKeys: [HelloWorldObject] @service(service: {className: "no.sikt.graphitron.example.service.HelloWorldService"})

    customerService: Customer @service(service: {className: "no.sikt.graphitron.example.service.CustomerService", method: "customer"})
    customerServiceWithJooqRecordInput(input: CustomerInput!): Customer @service(service: {className: "no.sikt.graphitron.example.service.CustomerService", method: "customer"})
    customerServiceWithJavaRecordInput(input: HelloWorldInputObject!): Customer @service(service: {className: "no.sikt.graphitron.example.service.CustomerService", method: "customer"})

    mockUpdateAddressAndCustomer: MockUpdateAddressAndCustomerPayload @service(service: {className: "no.sikt.graphitron.example.service.MockService"})
}

type MockUpdateAddressAndCustomerPayload {
    result: MockUpdateAddressAndCustomerResult
}

type MockUpdateAddressAndCustomerResult @record(record: {className: "no.sikt.graphitron.example.service.records.MockUpdateAddressAndCustomerResultRecord"}) {
    customers: [Customer] @splitQuery
    address: Address @splitQuery
    extraAddress: Address @field(name: "myAddress") @splitQuery
}

type HelloWorldObject @record(record: {className: "no.sikt.graphitron.example.service.records.HelloWorldRecord"}){
    greeting: String
    film: Film @splitQuery
    films: [Film] @splitQuery
    wrapper: CustomerWrapper
}

type CustomerWrapper {
    customer: Customer @splitQuery
}

input HelloWorldInputObject @record(record: {className: "no.sikt.graphitron.example.service.records.HelloWorldInput"}){
    name: String
    customerId: ID @nodeId(typeName: "Customer")
}

"""
Input type for testing @nodeId transformation to jOOQ record.
The customerId field has @nodeId and @field directives that will transform
the base64 node ID into a CustomerRecord populated with the unpacked ID.
"""
input NodeIdToJooqInputObject @record(record: {className: "no.sikt.graphitron.example.service.records.NodeIdToJooqInput"}){
    name: String
    customerId: ID @nodeId(typeName: "Customer") @field(name: "customer")
}

"""
Input type for testing merging of multiple @nodeId fields into a single jOOQ record.
Both customerId and inventoryId map to the same 'rental' field (RentalRecord).
The RentalRecord will have both CUSTOMER_ID and INVENTORY_ID populated.
"""
input NodeIdMergingInputObject @record(record: {className: "no.sikt.graphitron.example.service.records.NodeIdMergingInput"}){
    name: String
    customerId: ID @nodeId(typeName: "Customer") @field(name: "rental")
    inventoryId: ID @nodeId(typeName: "Inventory") @field(name: "rental")
}

"""
Input type for testing conflict detection when overlapping @nodeId fields have different values.
Both filmActorId and actorId write to the ACTOR_ID column of the FilmActorRecord.
If they encode different actor IDs, a conflict error should be thrown.
"""
input NodeIdConflictInputObject @record(record: {className: "no.sikt.graphitron.example.service.records.NodeIdConflictInput"}){
    name: String
    filmActorId: ID @nodeId(typeName: "FilmActor") @field(name: "filmActor")
    actorId: ID @nodeId(typeName: "Actor") @field(name: "filmActor")
}

input CustomerInput @table(name: "CUSTOMER") {
    id: ID! @nodeId(typeName: "Customer")
    addressId: ID @nodeId(typeName: "Address") @reference(path: [{key: "CUSTOMER__CUSTOMER_ADDRESS_ID_FKEY"}])
    firstName: String @field(name: "FIRST_NAME")
    usernames: [String!]
    pastAddressIds: [Int] @field(name: "PAST_ADDRESS_IDS")
}

extend type Mutation {
    singleCustomerMutation
    : CustomerWrapper @service(
        service: {
            className: "no.sikt.graphitron.example.service.CustomerService",
            method: "customer"
        }
    )
    createCustomerEmail
    : CreateCustomerEmailPayload @service(
        service: {
            className: "no.sikt.graphitron.example.service.CustomerService",
            method: "createCustomerEmail"
        }
    )
    updateCustomerEmail(input: [UpdateCustomerEmailInput!]!)
    : UpdateCustomerEmailPayload @service(
        service: {
            className: "no.sikt.graphitron.example.service.CustomerService",
            method: "updateCustomerEmail"
        }
    )
}

type CreateCustomerEmailPayload{
    customers: [Customer!]! @splitQuery
}

type UpdateCustomerEmailPayload{
  emailUpdates: [UpdateCustomerEmail!]
}

type UpdateCustomerEmail @record(record: {className: "no.sikt.graphitron.example.service.records.UpdateCustomerEmailResult"}){
  customerEmail: CustomerEmail!
}

type CustomerEmail @table(name: "CUSTOMER") {
  customerId: Int @field(name: "CUSTOMER_ID")
  email: String
}

input UpdateCustomerEmailInput @record(record: {className: "no.sikt.graphitron.example.service.records.UpdateCustomerEmailRecord"}){
  customerId: Int
  email: String
}

extend type City {
    filmsFromCity: [Film!]! @splitQuery @service(service: {className: "no.sikt.graphitron.example.service.MockService", method: "filmsFromCity"}) # Non-nullable for loadNonNullable approval test
}