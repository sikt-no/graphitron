"""
Type with a compound key.
"""
type FederatedStaff implements Node @node @table(name: "STAFF") @key(fields: "email username") {
    id: ID! @nodeId
    email: String
    username: String
}

"""
Type with a single ID key that contains a split query.
"""
type FederatedAddress implements Node @node @table(name: "ADDRESS") @key(fields: "id") {
    id: ID! @nodeId
    addressLine1: String! @field(name: "ADDRESS_")
    addressLine2: String @field(name: "ADDRESS2")
    zip: String @field(name: "POSTAL_CODE")
    city: City! @splitQuery
}

"""
Type with two keys.
"""
type FederatedCustomer implements Node @node @table(name: "CUSTOMER") @key(fields: "id") @key(fields: "firstName lastName") {
    id: ID! @nodeId
    firstName: String! @field(name: "FIRST_NAME")
    lastName: String! @field(name: "LAST_NAME")
    email: String
    externalEmail: String @external
    requiresEmail: String @requires(fields: "externalEmail")
    address: Address!
}

"""
Type with a non-resolvable key. Should not resolve, but currently does, see GG-375.
"""
type FederatedFilm implements Node @node @table(name: "FILM") @key(fields: "id", resolvable: false) {
    id: ID! @nodeId
    title: String
}

"""
Type with non-string key
"""
type FederatedPayment @table(name: "PAYMENT") @key(fields: "paymentId amount dateTime") {
    paymentId: Int @field(name: "PAYMENT_ID")
    amount: BigDecimal
    dateTime: LocalDateTime @field(name: "PAYMENT_DATE")
}

"""
Type with bad key which does not uniquely identify one entity (FILM_ACTOR has primary key with both ACTOR_ID and FILM_ID)
"""
type FederatedFilmActorWithBadKey @table(name: "FILM_ACTOR") @key(fields: "actorId") {
    actorId: Int! @field(name: "ACTOR_ID")
    filmId: Int! @field(name: "FILM_ID")
}
