extend schema
@link(url: "https://specs.apollo.dev/federation/v2.4",
    import: ["@key"])

scalar BigDecimal
scalar LocalDateTime

type Query {
    helloWorld: String @notGenerated

    customers(first: Int = 100, after: String): CustomerConnection
    activeCustomers: [Customer] @asConnection @condition(condition: {className: "no.sikt.graphitron.example.service.conditions.CustomerConditions", method: "activeCustomers"}, override: true)
    customersByAddress(addressId: ID! @nodeId(typeName: "Address")): [Customer] @asConnection
    customerWithJooqRecordInput(input: CustomerInput!): [Customer] @asConnection
    customerWithJavaRecordInput(input: CustomerJavaRecordInput!): [Customer] @asConnection
    customerLookup(customerIds: [ID!]! @lookupKey @nodeId(typeName: "Customer")): [Customer]
    customerLookupInt(id: Int! @field(name: "CUSTOMER_ID") @lookupKey): [Customer]

    films(orderBy: FilmsOrderByInput @orderBy): [Film] @asConnection
    filmLookup(filmId: [String!]! @lookupKey @field(name: "FILM_ID")): [Film]
    filmLookupWithAdditionalField(filmId: [String!]! @lookupKey @field(name: "FILM_ID"), title: [String!] @lookupKey): [Film]
    filmLookupWithInputObject(filmIds: [FilmLookupInput] @lookupKey): [Film]

    filmLists(category: String, categoryAsId: ID @field(name: "CATEGORY")): [FilmList]
    filmListsWithEnumRecord(input: FilmListEnumInput!): FilmList
    filmsWithDescriptionInput(input: [FilmDescriptionInput]): [Film]

    languages: [Language] @asConnection

    payments(dateTime: LocalDateTime @field(name: "PAYMENT_DATE"), amount: BigDecimal): [Payment] @asConnection
    paymentsFilteredByInventory(inventoryId: Int @field(name: "inventory_id") @reference(path: [{table: "RENTAL"}])): [Payment] @asConnection

    staff(input: StaffInput!): [Staff] @asConnection

    node(id: ID!): Node
    cities: [City] @asConnection
    citiesWithoutId: [CityWithoutID] @asConnection

    languageOrStaff: [LanguageStaffUnion] @asConnection

    inventories(orderBy: InventoriesOrderByInput @orderBy): [Inventory] @asConnection

    addressTableMethod(input: String @field(name: "POSTAL_CODE")): Address @tableMethod(tableMethodReference: {className: "no.sikt.graphitron.example.service.AddressTableMethod", method: "addressTableMethod"} )
    addressTableMethodSplitQuery(input: String @field(name: "POSTAL_CODE")): Address @tableMethod(tableMethodReference: {className: "no.sikt.graphitron.example.service.AddressTableMethod", method: "addressTableMethod"} )
    addressTableMethodConnection(input: String @field(name: "POSTAL_CODE")): [Address] @asConnection @tableMethod(tableMethodReference: {className: "no.sikt.graphitron.example.service.AddressTableMethod", method: "addressTableMethod"} )

    categories(in: [CategoryInput!]): [Category]
    category(in: CategoryInput!): Category
}

type Category implements Node @node @table {
    id: ID!
    name: String
}

input CategoryInput @table(name: "CATEGORY") {
    categoryId: ID! @nodeId(typeName: "Category")
}

interface Node {
    id: ID!
}

type CustomerConnection {
    edges: [CustomerConnectionEdge]
    pageInfo: PageInfo
    nodes: [Customer!]!
    totalCount: Int
}

type PageInfo {
    hasPreviousPage: Boolean!
    hasNextPage: Boolean!
    startCursor: String
    endCursor: String
}

type CustomerConnectionEdge {
    cursor: String
    node: Customer
}

type Customer implements Node @node @table {
    id: ID!
    name: CustomerName
    email: String
    emailAsId: ID @field(name: "EMAIL")
    address: Address!
    addressSplitQuery: Address @splitQuery
    addressSplitQueryWithKey: Address @splitQuery @reference(path: [{key: "CUSTOMER__CUSTOMER_ADDRESS_ID_FKEY"}])
    payments: [Payment] @reference(path: [{key: "PAYMENT__PAYMENT_CUSTOMER_ID_FKEY"}]) @splitQuery
}

type CustomerName {
    firstName: String! @field(name: "FIRST_NAME")
    lastName: String! @field(name: "LAST_NAME")
}

type Address implements Node @node @table @key(fields: "id", resolvable: false) {
    id: ID!
    addressLine1: String! @field(name: "ADDRESS_")
    addressLine2: String @field(name: "ADDRESS2")
    city: City!
    zip: String @field(name: "POSTAL_CODE")
    phone: String!
    citySplitQuery: City! @splitQuery
}

type City implements Node @table @node(typeId: "CityType"){
    id: ID!
    name: String! @field(name: "CITY_")
    countryName: String! @field(name: "COUNTRY_") @reference(path: [{table: "COUNTRY"}])
    addressExample: Address @splitQuery @notGenerated
    addresses: [Address] @splitQuery
    addressesPaginated: [Address] @splitQuery @asConnection
    payments: [Payment] @reference(path: [{table: "ADDRESS"}, {key: "CUSTOMER__CUSTOMER_ADDRESS_ID_FKEY"}, {table: "PAYMENT"}])
}

type CityWithoutID @table(name: "CITY") {
    cityId: Int @field(name: "CITY_ID")
    addresses: [Address]
}

type FilmList @table(name: "FILM_LIST") {
    description: String
    category: FilmCategoryEnum @field(name: "CATEGORY")
}

input FilmListEnumInput @table(name: "FILM_LIST") {
    description: String  # Redundant, but we do not want the test to fetch too much data.
    category: FilmCategoryEnum @field(name: "CATEGORY")
}

enum FilmCategoryEnum { # Note that this enum is not complete, and other values are also present in the database
    SPORTS @field(name: "Sports")
    CLASSICS @field(name: "Classics")
    COMEDY @field(name: "Comedy")
    ANIMATION @field(name: "Animation")
}

type Language implements Node @table @node(keyColumns: ["LANGUAGE_ID"]){
    id: ID!
    name: String
    films(releaseYear: Int @field(name: "RELEASE_YEAR")): [Film] @splitQuery @reference(path: [{key: "FILM__FILM_LANGUAGE_ID_FKEY"}]) @asConnection
    filmsWithoutPagination: [Film] @splitQuery @reference(path: [{key: "FILM__FILM_LANGUAGE_ID_FKEY"}])
}

type Film implements Node @node @table {
    id: ID!
    title: String
    description: String
    language: Language @reference(path: {key: "FILM__FILM_LANGUAGE_ID_FKEY"})
    #Film -> Inventory -> Store
    storesThatHaveThisFilm: [Store] @splitQuery @reference(path: [{key: "INVENTORY__INVENTORY_FILM_ID_FKEY"}, {table: "STORE"}])
    # Film -> Inventory -> Store -> Address -> City
    citiesWhereFilmIsStocked: [City] @splitQuery @reference(path: [{key: "INVENTORY__INVENTORY_FILM_ID_FKEY"}, {table: "STORE"}, {table: "ADDRESS"}, {table: "CITY"}])

    languageWrapper: LanguageWrapper

    originalLanguage: Language @reference(path: {key: "FILM__FILM_ORIGINAL_LANGUAGE_ID_FKEY"}) @splitQuery
    rentalDuration: Int @field(name: "RENTAL_DURATION")
}

type LanguageWrapper {
    originalLanguage: Language @reference(path: {key: "FILM__FILM_ORIGINAL_LANGUAGE_ID_FKEY"})
}

input FilmLookupInput {
    filmId: String! @field(name: "FILM_ID")
    title: String!
}

input FilmsOrderByInput {
    orderByField: FilmsOrderByFields!
    direction: OrderDirection!
}

# If the table directive is missing here, we get a bad crash without useful feedback.
input FilmInput @table(name: "FILM") {
    filmId: ID! @nodeId(typeName: "Film")
}

input FilmDescriptionInput @table(name: "FILM") {
    filmId: ID! @nodeId(typeName: "Film")
    description: String
}

enum FilmsOrderByFields {
    TITLE @index(name: "IDX_TITLE")
    LANGUAGE @index(name: "IDX_FK_LANGUAGE_ID")
}

type Inventory implements Node @node @table {
    id: ID!
    inventoryId: Int! @field(name: "INVENTORY_ID")
    filmId: Int! @field(name: "FILM_ID")
    storeId: Int! @field(name: "STORE_ID")
    film: Film
    lastUpdate: LocalDateTime @field(name: "LAST_UPDATE")
}

input InventoriesOrderByInput {
    orderByField: InventoriesOrderByFields!
    direction: OrderDirection!
}

enum InventoriesOrderByFields {
    STORE_ID_FILM_ID @index(name: "IDX_STORE_ID_FILM_ID")
}

enum OrderDirection {
    ASC
    DESC
}

type Payment @table {
    paymentId: Int @field(name: "PAYMENT_ID")
    amount: BigDecimal
    dateTime: LocalDateTime @field(name: "PAYMENT_DATE")
#    customer: CustomerRecord @splitQuery @service(service: {className: "no.sikt.graphitron.example.service.CustomerService"}) # kommentert ut pga bug i mapper
}

input StaffInput {
    username: String
    isManager: Boolean @condition(condition: {className: "no.sikt.graphitron.example.service.conditions.StaffConditions", method: "isManagerOfAStore"}, override: true)
    addressId: Int @field(name: "ADDRESS_ID") @reference(path: [{table: "ADDRESS"}])
    withAddressIdInCity300: Int @field(name: "ADDRESS_ID") @reference(path: [{key: "STAFF__STAFF_ADDRESS_ID_FKEY"}]) @condition(condition: {className: "no.sikt.graphitron.example.service.conditions.StaffConditions"})
}

type Staff implements Node @node @table(name: "STAFF") {
    id: ID!
    email: String
    username: String
}

union LanguageStaffUnion = Language | Staff

input CustomerJavaRecordInput @record(record: {className: "no.sikt.graphitron.example.service.records.CustomerJavaInput"}) {
    id: ID! @nodeId(typeName: "Customer")
    addressId: ID @nodeId(typeName: "Address") @reference(path: [{key: "CUSTOMER__CUSTOMER_ADDRESS_ID_FKEY"}])
    firstName: String @field(name: "FIRST_NAME")
}

type FilmActor implements Node @node @table(name: "FILM_ACTOR") {
    id: ID!
}

type FilmCategory implements Node @node @table(name: "FILM_CATEGORY") {
    id: ID!
}

type Store implements Node @node @table {
    id: ID!
}